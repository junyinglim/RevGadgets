#require(colorspace)
#require(ggplot2)
#
#require(ggtree)
#require(tidytree)
#require(treeio)
#require(gridExtra)
#require(ape)
#
#require(treeio)

matchNodes = function(phy) {

  # get some useful info
  num_tips = length(phy$tip.label)
  num_nodes = phy$Nnode
  tip_indexes = 1:num_tips
  node_indexes = num_tips + num_nodes:1

  node_map = data.frame(R=1:(num_tips + num_nodes), Rev=NA, visits=0)
  current_node = phy$Nnode + 2
  k = 1
  t = 1

  while(TRUE) {

    if ( current_node <= num_tips ) {
      node_map$Rev[node_map$R == current_node] = t
      current_node = phy$edge[phy$edge[,2] == current_node,1]
      t = t + 1
    } else {

      if ( node_map$visits[node_map$R == current_node] == 0 ) {
        node_map$Rev[node_map$R == current_node] = node_indexes[k]
        k = k + 1
      }
      node_map$visits[node_map$R == current_node] = node_map$visits[node_map$R == current_node] + 1

      if ( node_map$visits[node_map$R == current_node] == 1 ) {
        # go right
        current_node = phy$edge[phy$edge[,1] == current_node,2][2]
      } else if ( node_map$visits[node_map$R == current_node] == 2 ) {
        # go left
        current_node = phy$edge[phy$edge[,1] == current_node,2][1]
      } else if ( node_map$visits[node_map$R == current_node] == 3 ) {
        # go down
        if (current_node == num_tips + 1) {
          break
        } else {
          current_node = phy$edge[phy$edge[,2] == current_node,1]
        }
      }
    }

  }

  return(node_map[,1:2])

}

addLegend = function(tree, bins, colors, width=0.1, height=0.4, lwd=1, title="posterior probability", ...) {

  lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)

  x_left   = width
  x_right  = width + width * lastPP$x.lim[2]
  y_bottom = bins[-length(bins)] * height * length(tree$tip.label)
  y_top    = bins[-1] * height * length(tree$tip.label)

  ticks = pretty(bins)
  ticks = ticks[ticks > min(bins)]
  ticks = ticks[ticks < max(bins)]
  y_tick = ticks * height * length(tree$tip.label)
  if(lwd > 0) {
    segments(x0=x_right, x1=x_right + 0.01 * abs(diff(lastPP$x.lim)), y0=y_tick, lwd=lwd, ...)
  }
  text(x=x_right + 0.02 * abs(diff(lastPP$x.lim)), y=y_tick, label=ticks, adj=0, ...)
  rect(x_left, y_bottom, x_right, y_top, col=colors, border=colors)

  text(x_left - width / 1.5, mean(bins) * height * length(tree$tip.label), labels=title, srt=90, ...)
  # text(x=x_left, y=max(y_top) + 0.02 * length(tree$tip.label), labels=title, adj=0, ...)
  # points(x=x_left, y=max(y_top) + 0.05 * length(tree$tip.label))

}


################################################################################
#
# @brief Function to plot branch rates on a phylogeny..
#
#        For ...
#
# @date Last modified: 2019-05-24
# @author Sebastian Hoehna
# @version 1.0
# @since 2019-05-24, version 1.0.0
#
# @param    tree_file               character     Path to the ancestral state tree generated by RevBayes.
# @param    summary_statistic       character   The type of summary statistic to plot, can be lambda, mu, or net_div.
# @param    tree_layout             character   One of 'rectangular', 'slanted', 'fan', 'circular', 'radial', or 'unrooted'.
# @param    include_start_states    logical     Plot start and end ancestral states. Used for cladogenetic models.
# @param    burnin                  numeric     Percent burnin to discard, should be a number between 0 and 1.
#
################################################################################
plot_branch_rates_tree = function(tree_file,
                                  branch_rates_file,
                                  parameter_name="lambda",
                                  burnin = .25,
                                 ...) {

    if ( (parameter_name %in% c("lambda", "mu", "net_div")) == FALSE ) {
        print("Invalid parameter to plot.")
        return()
    }


    # read in tree
    tree = try(read.tree(tree_file), silent=TRUE)
    if ( class(tree) == "try-error"  ) {
        tree = try(read.nexus(tree_file), silent=TRUE)
    }

    map = matchNodes(tree)

    # read the posterior distributions
    samples = read.table(branch_rates_file, sep="\t", stringsAsFactors=FALSE, check.names=FALSE, header=TRUE)

    # calculate net diversification if needed
    if (parameter_name == "net_div") {
      lambdas <- as.matrix(samples[,grepl("avg_lambda", colnames(samples))])
      mus <-  as.matrix(samples[,grepl("avg_mu", colnames(samples))])
      net_divs <- as.data.frame(lambdas - mus)
      colnames(net_divs) <- gsub("lambda","net_div",colnames(net_divs))
      samples <- cbind(samples,net_divs)
    }
    
    # discard some burnin 
    n_samples = nrow(samples)
    # combine the mcmc output
    rate_output   = samples[-c(1:ceiling(n_samples * burnin)),grepl(paste0("avg_",parameter_name), colnames(samples))]

    # store the parameters
    rate_mean = colMeans(rate_output)

    branch_rates = rate_mean[-length(rate_mean)]

    # compute the intervals
    rate_intervals = pretty(unlist(branch_rates), n=1001)

    tree_tbl = as_data_frame(tree)

    # compute the legend
    legend_intervals = pretty(rate_intervals)
    legend_intervals = legend_intervals[legend_intervals > min(rate_intervals) & legend_intervals < max(rate_intervals)]
    legend_intervals_at = (legend_intervals - min(rate_intervals)) / diff(range(rate_intervals))


    # get the branch rates
    these_rates = branch_rates[paste0("avg_",parameter_name,"[",map$Rev[match(tree$edge[,2], map$R)],"]")]

    rate_tree = tree
    rate_tree$edge.length = these_rates
    rate_tbl = as_data_frame(rate_tree)

    tree_tbl  = as_data_frame(tree)
    tree_tbl$rates = rate_tbl$branch.length

    this_tree = as.treedata(tree_tbl)

    tree_plot = ggtree(this_tree, aes(color=rates)) + scale_color_continuous(paste0("branch-specific ",parameter_name), low="blue", high="green", limits=range(rate_intervals)) + theme(legend.position=c(0.2,0.85), legend.background=element_blank())


    return(tree_plot)
}


################################################################################
#
# @brief Function to plot branch-specific parameters on a phylogeny..
#
#        For ...
#
# @date Last modified: 2019-06-04
# @author Michael May and Sebastian Hoehna
# @version 1.0
# @since 2019-05-24, version 1.0.0
#
# @param    tree                    phylo       The tree on which to make the parameters
# @param    output_file             character   The file with the branch-specific estimates.
# @param    parameter_name          character   The name of the parameter to plot.
#
#
################################################################################
plot_relaxed_branch_rates_tree = function(tree,
                                          output_file,
                                          parameter_name="branch_rates",
                                          ...) {

  # map the branches between R and RevBayes
  map = matchNodes(tree)

  # read the posterior distributions
  samples = read.table(output_file, sep="\t", stringsAsFactors=FALSE, check.names=FALSE, header=TRUE)

  # discard some burnin (25%)
  burnin = 0.25
  n_samples = nrow(samples)

  # combine the mcmc output
  samples_thinned = samples[-c(1:ceiling(n_samples * burnin)), grepl(parameter_name, colnames(samples))]

  # store the parameters
  parameter_mean = colMeans(samples_thinned)

  # compute the intervals
  parameter_intervals = pretty(unlist(parameter_mean), n=1001)

  tree_tbl = as_data_frame(tree)

  # compute the legend
  legend_intervals = pretty(parameter_intervals)
  legend_intervals = legend_intervals[legend_intervals > min(parameter_intervals) & legend_intervals < max(parameter_intervals)]
  legend_intervals_at = (legend_intervals - min(parameter_intervals)) / diff(range(parameter_intervals))

  # get the branch rates
  these_rates = parameter_mean[paste0(parameter_name,"[",map$Rev[match(tree$edge[,2], map$R)],"]")]

  rate_tree = tree
  rate_tree$edge.length = these_rates
  rate_tbl = as_data_frame(rate_tree)

  tree_tbl  = as_data_frame(tree)
  tree_tbl$rates = rate_tbl$branch.length

  this_tree = as.treedata(tree_tbl)

  tree_plot = ggtree(this_tree, aes(color=rates)) + scale_color_continuous(parameter_name, low="blue", high="green", limits=range(parameter_intervals)) + theme(legend.position=c(0.2,0.85), legend.background=element_blank())


  return(tree_plot)
}

